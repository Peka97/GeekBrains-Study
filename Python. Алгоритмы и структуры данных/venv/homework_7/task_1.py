"""
Задание 1.
Отсортируйте по убыванию методом "пузырька" одномерный целочисленный массив,
заданный случайными числами на промежутке [-100; 100). Выведите на экран
исходный и отсортированный массивы.

Сортировка должна быть реализована в виде функции.

Обязательно доработайте алгоритм (сделайте его умнее)!

Идея доработки: если за проход по списку не совершается ни одной сортировки,
то завершение.

Обязательно сделайте замеры времени обеих реализаций и дайте ответ помогла ли
доработка и в каких случаях она будет эффективной.

Подсказка: обратите внимание, сортируем не по возрастанию, как в примере,
а по убыванию.
"""
from random import shuffle, randint
from timeit import timeit


def bubble_sort(lst_obj):
    n = 1
    issorted = True
    while n < len(lst_obj) and issorted:
        lst_obj_2 = lst_obj[:]
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        n += 1
    return lst_obj


def bubble_sort_2(lst_obj):
    n = 1
    while n < len(lst_obj):
        lst_obj_2 = lst_obj[:]
        for i in range(len(lst_obj) - n):
            if lst_obj[i] < lst_obj[i + 1]:
                lst_obj[i], lst_obj[i + 1] = lst_obj[i + 1], lst_obj[i]
        # Если у нас не было сортировок за проход в цикле for, то прерываем цикл
        if lst_obj_2 == lst_obj:
            break
        n += 1
    return lst_obj


if __name__ == '__main__':
    lst = [x for x in range(-100, 101)]
    shuffle(lst)

    print(lst)  # Исходный массив
    print(bubble_sort(lst[:]))  # Отсортированный массив

    print(timeit('bubble_sort(lst[:])', globals=globals(), number=1000))    # -> 2.4511985999997705
    print(timeit('bubble_sort_2(lst[:])', globals=globals(), number=1000))  # -> 2.07941160001792

    """
    Доработка оказалась эффективной, т.к. в определенном значении n у нас может сложиться уже отсортированный список и 
    мы можем не тратить время на дополнительные проходы по нему и сравнению значений до тех пор, пока n не придёт к
    своему пределу.
    
    При некоторых повторных запусках время работы второй функции было очень близко к первой функции, иногда даже
    больше, но в основном меньше. Но тут уже сыграет случай - чем раньше у нас получится отсортированный массив, тем 
    лучше себя проявит вторая функция.
    """
