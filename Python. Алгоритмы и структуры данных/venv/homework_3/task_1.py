from time import time


# Реализуем декоратор для фиксации времени выполнения функций
def get_time(func):
    def wrapper(obj):
        start = time()
        func(obj)
        result = time() - start
        print(result)

    return wrapper


# Реализуем функции для добавления элементов в список и словарь:
@get_time
def fill_list(lst: list) -> None:
    for n in range(1000000):  # O(1000000)
        lst.append(n)  # O(1)


@get_time
def fill_dict(dct: dict) -> None:
    for n in range(1000000):  # O(1000000)
        dct[n] = n  # O(1)


# Реализуем функции для считывания значений списка и словаря:
@get_time
def get_val_list(lst: list) -> None:
    for n in range(1000000):  # O(1000000)
        print(lst[n])  # O(1)


@get_time
def get_val_dict(dct: dict) -> None:
    for n in range(1000000):  # O(1000000)
        print(dct[n])  # O(1)


# Реализуем функции для удаления значений списка и словаря:
@get_time
def del_val_list(lst: list) -> None:
    for n in range(1000000):  # O(1000000)
        # Прописываем удаление первого элемента, т. к. при lst[n] на середине процесса мы вызовем IndexError
        del lst[0]  # O(1)


@get_time
def del_val_dict(dct: dict) -> None:
    for n in range(1000000):  # O(1000000)
        del dct[n]  # O(1)


if __name__ == '__main__':
    lst_1 = []
    dct_1 = {}

    # Тест А:
    fill_list(lst_1)  # -> ~0.73
    fill_dict(dct_1)  # -> ~0.78
    # Аналитика: не смотря на одинаковую сложность относительно Big O, операции добавления элемента в словарь прошли за
    # больший промежуток времени. Связано с тем, что происходит добавление ключа помимо самого элемента.

    # Тест B:
    get_val_list(lst_1)  # -> ~ 4.9
    get_val_dict(dct_1)  # -> ~ 4.9
    # Аналитика: значения у обоих функций за несколько тестов вышли от 4.8 до 5, но разница была крайне не существенной
    # (менее 0.01). В целом, можно считать, что скорость выполнения одинакова. При чтении не нужны дополнительные
    # операции для словаря, следовательно словарь не уступает списку.

    # Тест С:
    del_val_list(lst_1)  # -> ~410.8
    del_val_dict(dct_1)  # -> 0.065
    # Аналитика: список оказался в тысячи раз эффективнее в плане удаления элемента. Обосновано это, вероятно,
    # hash ссылками на объекты, которые работают быстрее поиска непосредственно самого объекта. Признаться, приятно
    # удивлён таким результатом.
