"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.
ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для второго скрипта
"""
from timeit import timeit
from task_1_1 import usage


@usage
def func_1(nums):
    """
    Задание 1.
    Приведен код, который позволяет сохранить в
    массиве индексы четных элементов другого массива
    Сделайте замеры времени выполнения кода с помощью модуля timeit
    Попробуйте оптимизировать код, чтобы снизить время выполнения
    Проведите повторные замеры
    ОБЯЗАТЕЛЬНО! Добавьте аналитику: что вы сделали и какой это принесло эффект
    """

    new_arr = []
    for i in range(len(nums)):
        if nums[i] % 2 == 0:
            new_arr.append(i)
    return new_arr


@usage
def func_2(nums):
    # Замена list на lс + избавление от метода append и лишней переменной new_arr привело к ускорению алгоритма
    # Плюс в одну строчку выглядит лаконичнее
    return [i for i in range(len(nums)) if nums[i] % 2 == 0]


@usage
def func_3(nums):
    yield (i for i in range(len(nums)) if nums[i] % 2 == 0)


if __name__ == '__main__':
    print(func_1(range(10000)))  # -> 0.2734375
    print(func_2(range(10000)))  # -> 0.20703125
    print(func_3(range(10000)))  # -> 0.00390625

    # Аналитика:
    # В прошлом при выполнении задания мы получили прирост по времени с использованием lc. Сейчас же убедились, что и по
    # памяти lc выигрывал. Не останавливаясь на достигнутом, оптимизировал код ещё и выполнил через generator. Результат
    # снова очень ощутимо обошёл соперников.