"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.

ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для четвёртого скрипта
"""
from memory_profiler import memory_usage


def usage(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func(*args)
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return mem_diff

    return wrapper

@usage
def natural_numbers(number: int = None, result: list = None) -> str:
    """
    Задание 2.	Подсчитать четные и нечетные цифры введенного натурального числа.
    Например, если введено число 34560, то у него 3 четные цифры
    (4, 6 и 0) и 2 нечетные (3 и 5).
    Подсказка:
    На каждом шаге вам нужно 'доставать' из числа очередную цифру
    и смотреть является ли она четной или нечетной.
    При этом увеличиваем соответствующий счетчик
    Пока все числа не извлечены, рекурсивные вызовы продолжаем
    Условие завершения рекурсии - все числа извлечены
    Используем операции % //. Операции взятия по индексу применять нельзя.
    Решите через рекурсию. В задании нельзя применять циклы.
    Пример:
    Введите число: 123
    Количество четных и нечетных цифр в числе равно: (1, 2)
    """
    # Шаг рекурсии
    if not number:
        number = int(input("Введите число: "))
        return natural_numbers(number, [0, 0])
    else:
        # Базовый случай
        if number < 10:
            if number % 10 % 2 == 0:
                result[0] = result[0] + 1
            else:
                result[1] = result[1] + 1
            return f'Количество четных и нечетных цифр в числе равно: {result}'
        else:
            # Шаг рекурсии
            if number % 10 % 2 == 0:
                result[0] = result[0] + 1
            else:
                result[1] = result[1] + 1
            number //= 10
            return natural_numbers(number, result)

@usage
def natural_numbers_2():
    number = input('Введите число: ')
    even_numbers = 0
    for el in number:
        if int(el) % 2 == 0:
            even_numbers += 1
    return f'Количество четных и нечетных цифр в числе равно: {(even_numbers, len(number) - even_numbers)}'


if __name__ == '__main__':
    print(natural_numbers())  # -> 0.01171875
    print(natural_numbers_2()) # -> 0.01171875


    """
    В данном случае с уходом от рекурсии и списков в результате мы оптимизировали нашу функцию
    """



