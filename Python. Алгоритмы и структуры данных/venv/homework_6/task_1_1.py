"""
Задание 1.
Вам нужно взять 5 любых скриптов, написанных ВАМИ в рамках работы над ДЗ
курсов Алгоритмы и Основы Python
На каждый скрипт нужно два решения - исходное и оптимизированное.
Вы берете исходное, пишете что это за задание и с какого оно курса.
Далее выполняете профилирование скрипта средствами memory_profiler
Вы оптимизируете исходное решение.
Далее выполняете профилирование скрипта средствами memory_profiler
Вам нужно написать аналитику, что вы сделали для оптимизации памяти и
чего добились.

ВНИМАНИЕ:
1) скрипты для оптимизации нужно брать только из сделанных вами ДЗ
курсов Алгоритмы и Основы
2) нельзя дублировать, коды, показанные на уроке
3) для каждого из 5 скриптов у вас отдельный файл, в нем должна быть версия до
и версия после оптимизации
4) желательно выбрать те скрипты, где есть что оптимизировать и не брать те,
где с памятью и так все в порядке
5) не нужно писать преподавателю '''я не могу найти что оптимизировать''', это
отговорки. Примеров оптимизации мы перечислили много: переход с массивов на
генераторы, numpy, использование слотов, применение del, сериализация и т.д.
Это файл для первого скрипта
"""
from memory_profiler import profile, memory_usage


def usage(func):
    def wrapper(*args, **kwargs):
        m1 = memory_usage()
        res = func(*args)
        m2 = memory_usage()
        mem_diff = m2[0] - m1[0]
        return mem_diff
    return wrapper


# @profile
@usage
def ascii(sym_idx: int, result_idx: int, result: list, done=False):
    def ascii_(sym_idx: int, result_idx: int, result: list, done=False):
        """
        Задание 5.	Вывести на экран коды и символы таблицы ASCII, начиная с символа
        под номером 32 и заканчивая 127-м включительно.
        Вывод выполнить в табличной форме: по десять пар "код-символ" в каждой строке.
        Пример:
        32 -   33 - ! 34 - " 35 - # 36 - $ 37 - % 38 - & 39 - ' 40 - ( 41 - )
        42 - * 43 - + 44 - , 45 - - 46 - . 47 - / 48 - 0 49 - 1 50 - 2 51 - 3
        52 - 4 53 - 5 54 - 6 55 - 7 56 - 8 57 - 9 58 - : 59 - ; 60 - < 61 - =
        62 - > 63 - ? 64 - @ 65 - A 66 - B 67 - C 68 - D 69 - E 70 - F 71 - G
        72 - H 73 - I 74 - J 75 - K 76 - L 77 - M 78 - N 79 - O 80 - P 81 - Q
        82 - R 83 - S 84 - T 85 - U 86 - V 87 - W 88 - X 89 - Y 90 - Z 91 - [
        92 - \ 93 - ] 94 - ^ 95 - _ 96 - ` 97 - a 98 - b 99 - c 100 - d 101 - e
        102 - f 103 - g 104 - h 105 - i 106 - j 107 - k 108 - l 109 - m 110 - n 111 - o
        112 - p 113 - q 114 - r 115 - s 116 - t 117 - u 118 - v 119 - w 120 - x 121 - y
        122 - z 123 - { 124 - | 125 - } 126 - ~ 127 - 
        Решите через рекурсию. В задании нельзя применять циклы.
        Допускается исп-е встроенных ф-ций
        """

        # Базовый случай
        if done:
            print(*result, sep='\n')
        # Шаг рекурсии
        elif sym_idx < 128 and len(result[result_idx]) < 9 and not done:
            result[result_idx].append(f'{sym_idx} - {chr(sym_idx)}')
            return ascii_(sym_idx + 1, result_idx, result)
        # Шаг рекурсии
        elif len(result[result_idx]) == 9:
            result[result_idx].append(f'{sym_idx} - {chr(sym_idx)}')
            return ascii_(sym_idx + 1, result_idx + 1, result)
        # Шаг рекурсии
        elif sym_idx == 128:
            return ascii_(sym_idx, result_idx, result, True)

    ascii_(sym_idx, result_idx, result)


@usage
def ascii_2(*args):
    return [f'{n} - {chr(n)}' if idx % 9 != 0 else f'\n{n} - {chr(n)}' for idx, n in enumerate(range(32, 128))]


@usage
def ascii_3(*args):
    for n in range(32, 128):
        yield f'{n} - {chr(n)}' if n not in (41, 51, 61, 71, 81, 91, 101, 111, 121) else f'\n{n} - {chr(n)}'


if __name__ == '__main__':
    print(ascii(32, 0, [[], [], [], [], [], [], [], [], [], [], ])) # -> ~ 0.0548
    print(ascii_2())                                                # -> ~ 0.0039
    print(ascii_3())                                                # -> ~ 0.0039

    # Комментарий:
    # Почему-то профайлер отказывается работать с оптимизированной версией.
    # Почему то в случае последовательного запуска функций первая получала адекватный результат, а остальные 0.0, однако
    # при запуске по одному результат отличен от 0.

    # Аналитика:
    # При проведении оптимизации мы допились гораздо более экономичных алгоритмов. Показатель памяти улучшен на ~1400%.
    # Добились такого тем, что ушли от списка к lc или generator. Плюс сам код стал намного лаконичнее.
